# Java-Refactoring

##リファクタリングとは
外部から見たプログラムの振る舞いを変えずに、プログラム内部の構造を改善する事です。  
この定義を要点は次の２つです。

- **リファクタリングを行っても、外部から見たプログラムの振る舞いは変わらない**
- **リファクタリングを行うと、プログラム内部の構造は改善する**

##リファクタリング・クイズ

###「バグとり」はリファクタリングか？
答え：いいえ

プログラムの振る舞いが変わってしまうため、リファクタリングではなない。

###「機能の追加」はリファクタリングか？
答え：いいえ

プログラムの振る舞いが変わってしまうため、リファクタリングではなない。

###「ソースコードの整理」はリファクタリングか？
答え：惜しいが、必ずしもそうではない

ソースコードを整理すると、ソースコードがよみやすくなる。
これは確かに改善の一種だが、リファクタリングとは限らない。  
なぜなら、ソースコードを整理しただけではプログラムの振る舞いが変化している可能性がある。  
リファクタリングはソースコードを整理することではない。  
かならず「外部から見たプログラムの振る舞いが変わっていない」という事を確かめながら進む。

##リファクタリングとユニットテスト
振る舞いが本当に変化していないことを、どうすれば確かめられるか。  
それは単体テスト、もしくはユニットテストを行う。  
リファクタリングを行うときには、その前後にテストを行い、振る舞いが変化していない事を確かめる。

- リファクタリング前にテスト
- リファクタリングを行う
- リファクタリング後に再度テスト

リファクタリングにテストは必須、JUnitを使ってもいい。

##リファクタリングの目的

###バグを見つけやすくする
プログラムが整理され、バグが見つけやすくなる。  
混乱したコードはデバッグしにくい。

###機能追加しやすくなる
一般に、機能追加を重ねるとソースコードは複雑になっていくため、後の機能追加が難しくなり、余計に時間に追われるという悪循環になる。

###レビューしやすくなる
コードレビューがしやすくなる。  
リファクタリングを行ってきれいにしたコードは読みやすく、理解しやすくなる

##リファクタリングの限界
リファクタリングはいつでもできるわけではなく、リファクタリングを適用できない場合もある

###プログラムがまだ動いていない場合
作りかけで動いていないプログラムはリファクタリングできない。  
まずは動くプログラムをつくろう。
同様に、設計やコーディングがまずく、バグだらけで使えないプログラムに対してもリファクタリングはできない。

###あまりにも時間がない場合
納期が厳しいときにリファクタリングするのは懸命ではない。  
リファクタリングの効果というのは、時間的に少し後からじわじわ効いてくるものである。  
納期直前に大きなリファクタリングはやめる

##リファクタリングと「不吉な匂い」
###不吉な匂いとは
具体的にどこを改善したらいいのか？  
リファクタリングを必要としている部分のことを「**不吉な匂い**」と呼ぶ。
不吉な匂いとはプログラムで以下の部分

- 理解しにくい
- 修正しにくい
- 拡張しにくい

##不吉な匂いを示すセリフ
上の22個を覚えるのは大変なので、まずは６つ紹介
このセリフを口にしたくなったらリファクタリングを必要としているのかも。

- ダブってる
- 長すぎ
- 多すぎ
- 名前があってない
- 公開しすぎ
- オブジェクト指向っぽくない

###ダブってる
ダブってる＝重複したコード  
まとまりを探しだして「メソッドの抽出」や、「クラスの抽出」というリファクタリングを検討する。  
nullチェックがあちこちに見つかるようなら、「ヌルオブジェクトの導入」というリファクタリングが有効。
エラーチェックが多いときには、「例外によるエラーコードの置き換え」を検討する。

###長すぎ
長すぎる＝理解が難しい

「メソッドの抽出」というリファクタリングを行うのが有効。  
コードのまとまりを見つけてそれに新たなメソッドにするというリファクタリング。  
巨大なクラスは担っている責務が多すぎるので、「クラスの抽出」を検討する。  

###多すぎ
クラスのが大きいからといって抽出しすぎると、今度は増えすぎて理解を妨げる事になる。  
「仲介人の削除」というリファクタリングや、「クラスのインライン化」や、「メソッドのインライン化」などのリファクタリングを検討する。  

###名前があってない
setItemメソッドなのに、何もセットしてない！など  

名前は重要、コードを書くときは適切な名前をつけるよう注意しなければならない。  
名前は一回つけて終わりではない、プログラムは生きている。
修正を加えていくうちに名前が不適切になる場合は多い。
表現したい概念と名前が合っていないのを発見したら、影響する範囲を見極めた上で適切な名前に変更する。  

メソッド名の変更、意味がわかりにくい式に名前をつける「説明用変数の導入」、同じ変数を使いまわすのをやめる「一時変数の分離」が名前に関連したリファクタリングである。

###公開しすぎ

メソッドが呼べないからといって全部をpublicにするのは間違い、それはクラスの実装を公開しすぎ。  
publicになったメソッドは他から呼ばれる可能があるため、メソッドを削除する際に思わぬ場所から呼び出されて使用されている場合がる。
フィールドも同じく、公開しすぎはダメ、「フィールドのカプセル化」を検討する。  
クラスの名前も公開しすぎはいけない。  
newを使ってインスタンスを生成するとき、newの後には具体的なクラス名を書くが、この場合、クラス名を変更するのは難しくなる。
なぜなら、プログラム中でインスタンスをnewしている部分をすべて変更しなければならないから。  
そんなときには、「Factory Methodによるコンストラクタの置き換え」というリファクタリングを検討する。　
Factory Methodによってクラス名を隠す。  
適切に情報を隠すことを一般に**情報隠蔽(information hiding)** という。
情報隠蔽は極めて重要。

###オブジェクト指向っぽくない
プログラムのあちこちでinstanceofを使っている、オブジェクト指向っぽくない  
わかりにくいかもしれないが、たとえば以下の状況
- switch文やif文を使って、処理を分岐ばかりしている
- instanceofを使って、オブジェクトが属するクラスばかり調べている
- intばかり使って、専用のクラスを作らない
